---
title: "Packet Crafting الجزء الأول"
date: 2008-12-23 00:31:58 -0500
categories: ["Firewalls", "Linux Security", "Networks", "PenTest"]
tags: ["hping2", "nmap", "Packet Crafting"]
permalink: "/2008/12/23/packet-crafting-part-1/"
reading_time: 13
---

**السلام عليكم ورحمة الله وبركاته**

هناك مجموعة كبيرة من المواضيع التي تختص بالجدران النارية وأيضاً بالـ **Penetration Testing** سأقوم بكتابتها في الأيام والشهور القادمة، وأحببت أن يكون أول هذه المواضيع هو عن الـ **Packet Crafting**، وذلك بإستعمال الأداة **hping** و **hping2** … السبب الذي جعلني أختار هذا الموضوع كبداية لهذه الدروس التي سأكتبها هو كون أساس كل التعاملات على الشبكة هو البروتوكولات والحزم **Packets** التي تنقل البيانات هذه، سواءاً كانت هذه الحزم من نوع **tcp** أو **icmp** أو غيرها … ولهذا إذا عرفنا كيف يتم التعامل مع هذه الحزم **Packets** فمن السهل علينا مواصلة المشوار في المواضيع المتقدمة الأخرى … رغم إنه هذا الموضوع للأمانة ليس موضوع مبتديء وأعتبره موضوع متقدم للغاية ولكن سأبدأ بإذن الله من الأمور الإبتدائية حتى نصل للأمور المعقدة … طبعاً لن يتم ذكر كل شيء حول هذه الأداة ولكن سأذكر أهم الأمور التي ستحتاجها والباقي عليك أنت … ﻷن لو حاولت وضع كل شيء فسأحتاج الى شهور وسأحتاج الى تأليف كتاب كامل …

**ماذا ستغطي هذه السلسلة؟**

**الجزء الأول:**

**– مقدمة عن TCP/IP وأنواع المؤشرات/الأعلام flags**

**– مقدمة على hping**

**– تعريف Packet crafting**

**– تنصيب hping**

**– التحقق من وجود الهدف من خلال صناعة حزمة TCP SYN**

**– التحقق من وجود الهدف من خلال صناعة حزمة TCP ACK**

**– التحقق من وجود الهدف من خلال صناعة حزمة TCP FIN**

**– التحقق من وجود الهدف من خلال صناعة حزمة TCP Null**

**– التحقق من وجود الهدف من خلال صناعة حزمة TCP Xmas**

**الجزء الثاني:**

**– التعامل مع البروتوكول UDP**

**– غيرها**

**الجزء الثالث:**

**– كيفية كشف المنافذ التي تقع خلف الجدران النارية**

**– غيرها**

**الجزء الرابع:**

**– أوامر متقدمة في Packet Crafting**

**– كيفية إرسال Payload من خلال الحزم**

**طريقة عمل الإتصالات في tcp/ip:**

لتوضح هذه المسألة المهمة سنأخذ مثال التالي/ مثلاً لتصفح موقع مجتمع لينوكس العربي، تتم من خلال إرسال حزمة **Packet** نوعها (أو العلم الخاص بها) **SYN** الى المنفذ رقم **80** (المنفذ الخاص بخادم الويب أباتشي) وذلك ليخبره هل بإمكاننا عمل إتصال معك؟ بعد ذلك يقوم الخادم الذي عليه مجتمع لينوكس العربي بالرد عليه من خلال حزمة **Packet** نوعها **SYN/ACK**، يخبره نعم أنا جاهز. بعد ذلك يعود جهازك لإرسال حزمة نوعها **ACK** الى الخادم يخبره بإن الأمور أذن تمام لنفتح الإتصال بيننا. طبعاً هذه في حالة كان الخادم الذي عليه مجتمع لينوكس العربي يعمل، ولو لم يكن يعمل فسيكون الجواب مختلف وطريقة التعامل مختلفة، سنراها في الموضوع بإذن الله.

هذه قاعدة مهمة مهمة مهمة جداً وهي تسمى بعالم الشبكات

```
3 Way Handshaking
```

**\\ قواعد مهمة جداً //**

**أولاً:** لفهم باقي الموضوع عليك أن تحفظ هذه القاعدة وعليك أن تعرف بإن طريقة المراسلة الناجحة (إرسال/إستقبال) تتم من خلال:

```
A -----(SYN)------> B
A  B
```

الجهاز **A** يرسل حزمة من نوع **SYN** الجهاز المستقبل **B** يرد عليه بحزمة نوعها **SYN/ACK** وبعد ذلك يرجع الجهاز A يرد بحزمة نوعها **ACK** … هذه هي كما ذكرت بالأعلى**3 Way Handshaking** …

هذه القاعدة لا تنطبق دائماً وحسب ما فهمت على نظام ثقيل الطينة **Win2k** و **Win2003** …

**ثانياً:** لفهم باقي الموضوع عليك أن تحفظ هذه القاعدة وعليك أن تعرف بإن طريقة المراسلة الفاشلة أو الغير كاملة تتم من خلال:

```
A -----(SYN)------> B
A أي الجهاز **A** يرسل حزمة من نوع **SYN** والجهاز **B** بسبب كون المنفذ المطلوب غير مستعمل أو غير متوفر الى آخره، يرد عليه بحزمة نوعها **RST/ACK** تعلمه بإنه غير قادر على إكمال الـ  **3 Way Handshaking** …

**ثالثاً:** قم بإيقاف عمل الجدار الناري لديك على الجهاز الذي ستقوم بعملية الفحص، فكما ذكرت لك الموضوع ليس لكي أقوم أنا بإختبار الجدار الناري لديك، وإنما تقوم بإختباره أنت بنفسك بعد أن تنتهي من قراءة الموضوع …

**رابعاً:** أنواع الأعلام/المؤشرات **flags** التي يستعملها **tcp**:

– العلم **SYN** هو العلم المستعمل لبداية الإتصال ويسمى وهو إختصار لـ **Initial Synchronous** …

– العلم **ACK** هو العلم المستعمل للرد والإعتراف وهو إختصار لـ **Acknowledgment** …

– العلم **RST** هو العلم المستعمل لطلب إنهاء الإتصال وهو إختصار لـ **Reset** …

– العلم **FIN** هو العلم المستعمل لإنهاء الإرسال وهو إختصار لـ **Finish** …

– يوجد أعلام اخرى لن نتطرق لها في الجزء الأول وسأشرحهم في وقتهم مثل: **PUSH** و **URG** و **X** و **Y** …

**الرجاء لا تنسى هذه القواعد ::20 …**

**لماذا hping ؟**

الجواب: بصراحة على نظام ثقيل الطينة وجدت برنامج إسمه **Engage Packet Builder** وهو رائع جداً ولكن على جنو/لينوكس لم أتعرف على برنامج لهذه الأمور إلا بعد أن قرأت كتاب **Hands-On Ethical Hacking and Network Defense** في صفحة **99**، وبإن هذه من أقوى الأدوات التي يستعملونها خبراء الحماية وإختبار الحماية … وآكاد أجزم بإن قلة من الناس يعرفون بإن **hping** قادر على القيام بذلك …

**ملاحظة مهمة جداً:** قبل أن تقوم بالتطبيق، إرجوا أن تقوم بإيقاف الجدار الناري لديك، فالموضوع للتوضيح وللتعريف والمساعدة، وليس أن يقوم الموضوع بتحليل الجدار الناري الموجود عند كل قاريء لهذا الموضوع … بعد نهاية الموضوع سيكون دورك أنت أن تعيد تشغيل الجدار الناري عندك والقيام بالإختبارات التي تعلمتها عليه …

**تعريف: Packet crafting**

هو عبارة عن تقنية لصناعة حزم **Packets** معينة وذلك للتحقق من قواعد وقوانين الجدران النارية وإيجاد نقاط ضعف فيها. هذا بشكل مبسط للغاية.

**كيف تتم عملية بناء الحزم هذه؟**

الجواب: من خلال إستعمال أدوات قادرة على صناعة هذه الحزم، وفي موضوعنا هذا سنقوم بإستعمال البرنامج **hping**.

الآن عندما نقوم بعمل مسح **scan** على هدف معيين، فإن كان الهدف والمنفذ **Port** الذي أرسلنا عليه الحزمة مفتوح؟ فإنه سنستلم رد منه بشكل طبيعي في أغلب الأحوال. وإن كان الهدف الذي عملنا على مسح خلف جدار ناري فإنه ربما لا نستلم رد وربما نستلم رد منه. هذا يوضح لنا مسألة مهمة جداً بخصوص المسح، وهي إنه نواتج المسح تكون أحدى هذه الثلاث حالات:

**– المنفذ مفتوح Port Open**

**– المنفذ مغلق Port Closed**

**– المنفذ مفلتر Port Filtered**

المنفذ المفتوح واضح يعني نستطيع أن نتعامل معه بسهولة … والمغلق يعني إنه ربما لا يوجد خدمة تعمل عليه، ولهذا هو مغلق … والمنفذ المفلتر هو المشكلة !!! المنفذ المفلتر لا يوضح لنا هل المنفذ يوجد خدمة تتنصت عليه أم لا؟ ونحن غير قادرين على إكتشافها بسبب حجب الجدار الناري لنا … ولا يوضح إذا كان لا يوجد تنصت عليه أصلاً … ولهذا سنستعمل تقنية الـ **Packet Crafting** في معرفة هل يوجد خدمة تعمل على المنفذ **X** ولكن الجدار الناري يحجبنا من الوصول أليه أم لا …

في السابق كنا نستطيع أن نعرف هل الهدف موجود أم لا من خلال إستعمال الأمر **ping** ولكن اليوم الكثير من الجدران النارية والأنظمة تقوم بشكل أساسي أو من خلال إعدادها لرفض الرد على الحزم من نوع **icmp** ولهذا سنحتاج لأدوات وطرق أخرى لكشف الهدف وكشف المنافذ المفتوحة لديه … ولهذا سنقوم بإستعمال الأداة **hping2** في طريقة كشف الأهداف وكشف الأنظمة والتحقق من قوة قوانين الجدار الناري لدينا …

**تعريف: ما هو hping2 ؟**

**الجواب:** هي عبارة عن أداة قادرة على تجميع، صناعة، وتحليل الحزم. الاداة قادرة على التعامل مع كل من **tcp**، **udp**، **icmp**، وغيرها. وأليكم أهم ميزات هذه الاداة:

**–** فحص قواعد وقوانين الجدران النارية …

**–** مسح متقدم للمنافذ …

**–** فحص أداء الشبكة من خلال إستعمال بروتوكولات مختلفة، حزم بأحجام مختلفة، **TOS** وتجزيء الحزم **fragmentation** …

**–** معرفة مسارات الـ **MTU** أي **Path MTU discovery** (معلش ما عرفت أترجمها!!!) …

**–** عمل **traceroute** متقدم على جميع البروتوكولات المدعومة …

**–** إكتشاف نظم التشغيل على الجهة المستهدفة أي **Remote OS fingerprinting** …

**–** مراجعة مكدس الـ **TCP/IP** أو ما يسمى **TCP/IP stacks auditing** …

**–** يمكن أن يستعمل من قبلنا نحن الطلاب لتعلم البروتوكول **TCP/IP** …

**–** غير ذلك …

**إذا كنت تريد معرفة المزيد؟ عليك بـ:**

```
man hping
```

```
http://hping.org/documentation
```

سأحاول من خلال هذه السلسلة أن أقوم بتوضيح وإستعمال أغلب الأمور والإمكانيات التي يوفرها لنا **hping2** وسنبدأ بأمور بسيطة مثل صناعة الحزم معينة الى أن نقوم بعملية تجاوز الجدران النارية وإكتشاف ما خلفها ومن ثم تحليل ومعرفة نظم التشغيل الموجودة على الهدف أو الطرف الثاني …

**لكي تستطيع متابعة السلسلة معي، قم بالبداية بتنصيب الاداة:**

يمكنك تنصيب **hping** بسهولة على جميع توزيعات جنو/لينوكس … منها من خلال إستعمال المكتبة الخاصة بتوزيعتك ومنها من خلال تحميله من الموقع الرسمي وتركيبه … لتركيبه في توزيعة دبيان/أوبنتو:

```
apt-get install hping
```

فيدورا/سنتوس:

```
yum -y install hping
```

أو قم بتحميل الملفات المصدرية من [الموقع الرسمي](http://www.hping.org/download.html) وقم بتركيبهم كالتالي:

```
./configure
make
make install
```

**الآن ركبت الأداة لنبدأ بالعمل … والخطوة الأولى هي أرجوا أن تقوم بتحديد الهدف المطلوب، ويمكنك القيام بذلك من خلال عمل مسح على النظام المستهدف بإستعمال nmap كبداية أو قم بقراءة الموضوع كامل وبعد ذلك قم بالتطبيق لمعرفة كيف تكتشف المنافذ والأجهزة … وأرجوا أن تنفذ الأوامر بالمستخدم root أوك**::20

**التحقق من وجود الهدف من خلال صناعة حزمة TCP SYN:**

في هذه الطريقة سنقوم بإرسال حزمة نوعها **SYN** الى الهدف والتي بالغالب إن كانت على منفذ مفتوح سيكون الناتج لها هو **SYN/ACK** كما أتفقنا في القواعد التي بالأعلى. أما إذا كان المنفذ مغلق فإنه بالوضع الطبيعي سيصل لنا جواب بحزمة نوعها **RST/ACK**.

لصناعة هذه الحزمة وتجربتها نفذ الأمر التالي:

```
# hping2 172.16.0.10 -S -c 1 -p 22
```

لنقم بتوضيح الخيارات المستعملة:

**الخيار الأول** S- هو لكي نعمل حزمة نوعها **SYN** …

**الخيار الثاني** c- وبعده 1 هو لكي نقوم بإرسال حزمة واحدة فقط (لإرسال أكثر حدد العدد الذي تريده) …

**الخيار الثالث** p- هو لتحديد المنفذ الذي نريد الإرسال عليه وهنا أخترنا 22 …

الجواب يفترض يكون مثل هذا:

```
HPING 172.16.0.10 (eth0 172.16.0.10): S set, 40 headers + 0 data bytes
len=46 ip=172.16.0.10 ttl=128 DF id=23622 sport=22 flags=SA seq=0 win=16616 rtt=0.4 ms
```

ما قمنا به هنا هو إرسال حزمة **SYN** على المنفذ 22 (**SSH**) لمعرفة هل هو مغلق أم مفتوح، وكما تلاحظون هو مفتوح. طبعاً بعد أن وصل لنا الرد والذي كان عبارة عن حزمة **SYN/ACK** وسأخبرك كيف عرفت ذلك، الآن الطرف الآخر ينتظر منا ماذا؟ ينتظر الحزمة **ACK** لنرسلها له. ولكن لأننا لا نريد عمل الـ **3Way Handshaking** فإنه خلاص لن تتم الخطوات الثلاثة وينتهي الإتصال (بعد **delay time** معيين).

الآن لنحلل جميع المعلومات التي ظهرت لدينا:

S set – تعني إن الحزمة نوعها SYN

40 headers + 0 data bytes – تبيين لنا بإنه لم يتم إضافة أي بيانات الى الحزمة

len – حجم الحزمة الراجعة لنا بالبايتات طبعاً من دون الهيدر الخاص Data Link Layer وبعض الأحيان حاجات أخرى

ip – الأي بي الخاص بالهدف

ttl – قيمة الـ time-to-live والتي هي هنا 128، أي تستطيع القفز 128 مرة قبل أن يتم رميها من قبل الراوترات

DF – تعني إن البت don’t fragment تم تحديده وهذا لكي لا يتم تقسيم الحزمة الى أقسام وأجزاء صغيرة، سنرى تفاصيل أخرى عليها لاحقا

id – هذه هي الـ ID الخاص بالأي بي

sport – هذا هو المنفذ الذي قدمت منه الحزمة

flags – تعطينا أسماء الأعلام المستعملة للحزمة، وهنا العلم هو SA والتي تعني SYN/ACK وبهذا عرفنا بإنه الرد كان SYN/ACK

seq – الرقم التسلسلي المكون من 32bit الموجود في TCP header

win – حجم نافذة الـ TCP

rtt = round trip time في الـ milliseconds.

هكذا رأينا ماذا سيحصل لو إننا قمنا بإرسال حزمة الى منفذ مفتوح، الآن لنقم بإرسال نفس الحزمة ولكن على منفذ مغلق، وذلك من خلال الأمر التالي:

```
# hping2 172.16.0.10 -S -c 1 -p 2
```

أنظروا الى الجواب:

```
HPING 172.16.0.10 (eth0 172.16.0.10): S set, 40 headers + 0 data bytes
len=46 ip=172.16.0.10 ttl=128 DF id=23677 sport=2 flags=RA seq=0 win=16616 rtt=0.5 ms
```

الآن لو تلاحظون ما هو الإختلاف الآن؟ الجواب هو بالأعلام **flags** التي عادت لنا، حيث هذه المرة عاد الجواب بعلم **RA** والذي يعني **RST/ACK** … وهذا هو الرد الطبيعي والذي يؤكد بإن المنفذ حالياً لا يستقبل أي إتصال **TCP/IP** …

**التحقق من وجود الهدف من خلال صناعة حزمة TCP ACK:**

في هذه الطريقة سنقوم بإرسال حزمة نوعها **ACK** أي **Acknowledgment** الى الهدف. في هذه الحالة سواءاً كان المنفذ على الهدف مفتوح أو مغلق سيقوم بالرد علينا بحزمة نوعها **RST/ACK**. هذه الطريقة تفيد في معرفة هل الهدف **Alive** أو لا.

لصناعة هذه الحزمة وتجربتها نفذ الأمر التالي:

```
# hping2 172.16.0.10 -A -c 1 -p 22
```

الخيار الجديد هنا هو A- والذي يعني بإنه الحزمة نوعها **ACK** أو الأعلام المؤشرة عليها نوعها **ACK**.

الجواب هو:

```
HPING 172.16.0.10 (eth0 172.16.0.10): A set, 40 headers + 0 data bytes
len=46 ip=172.16.0.10 ttl=128 id=23750 sport=22 flags=R seq=0 win=0 rtt=1.3 ms
```

أنظروا الى العلم **flags** مؤشر عليه **R** والتي تعني بإن الحزمة نوعها **RST**. وبعبارة أخرى تعني بإن الحزمة وصلت الى الطرف الآخر وأستطاع الرد عليها.

طريقة أخرى لمعرفة هل الجهاز/الهدف موجود **Alive** ام لا هي من خلال إرسال حزمة **SYN/ACK** كما في التالي:

```
# hping2 172.16.0.10 -SA -c 1 -p 22
```

الجواب:

```
HPING 172.16.0.10 (eth0 172.16.0.10): SA set, 40 headers + 0 data bytes
len=46 ip=172.16.0.10 ttl=62 DF id=12366 sport=22 flags=R seq=0 win=0 rtt=0.3 ms
```

طبعاً سيكون الرد أيضاً كالعادة هو **RST** وكما تلاحظون هو فعلا كذلك من خلال المؤشر **flags** يقول **R**. وهذا هو الجواب سواءاً كان المنفذ مفتوح أو مغلق.

**التحقق من وجود الهدف من خلال صناعة حزمة TCP FIN:**

سنقوم بصناعة وإرسال حزمة المؤشر عليها نوعه **FIN** وذلك لكي نعرف هل المنفذ مفتوح أو مغلق. الآن المنفذ المفتوح سيقوم بعمل **DROP** للحزمة التي نوعها **FIN** وذلك لأنه يعرف بإنها لإنهاء الإتصال (على الرغم من كونه لم يحصل إتصال أصلاً)، والمنفذ المغلق سيقوم بالرد علينا بالحزمة **RST/ACK**. نقطة مهمة يجب أن تعيروا لها أهمية وهي إن هذه الردود ستختلف من نظام الى آخر وذلك لأنه الـ **TCP Stack** في الأنظمة مختلف ومن خلالهم أصلاً يتم التعرف على نوع النظام (**OS Fingerprinting**). سأقوم بشرح ذلك إن شاء الله بعدة طرق سواءاً من خلال **hping** أو من خلال **nmap** أو من خلال أدوات أخرى.

طيب خلونه نجرب:

```
# hping2 172.16.0.10 -F -c 1 -p 21
```

الجواب:

```
HPING 172.16.0.10 (eth0 172.16.0.10): F set, 40 headers + 0 data bytes
len=46 ip=172.16.0.10 ttl=128 id=19872 sport=21 flags=RA seq=0 win=0 rtt=1.1 ms
```

الآن أستعملنا الخيار F- وذلك لصناعة حزمة من نوع **FIN** والجواب يؤكد رجوع رد لنا نوعه **RST/ACK** من خلال المؤشرات **flags** الواضحة أمامنا بإنها **RA**، وهذا يعني بإن المنفذ ماذا؟ مغلق.

**التحقق من وجود الهدف من خلال صناعة حزمة TCP Null:**

هذه الطريقة تتم من خلال إرسال حزمة بدون أي مؤشر، وأيضاً الرد عليها يعتمد على نوع النظام الذي تقوم بعملية التحقيق وبصراحة حسب ما قرأت من الكثير من الكتاب يقولون هي غير مفيدة خاصة إذا أخذنا بنظر الإعتبار بإنه لا يوجد حزمة نوعها **Null** بالإضافة الى كون الكثير من الأجهزة (الجدران النارية) تقوم بعملية فلترة لها. لكن ياله خلونا نجرب ::18

```
# hping2 172.16.0.10 -c 1 -p 333
```

**التحقق من وجود الهدف من خلال صناعة حزمة TCP Xmas:**

هذه الطريقة هي طريقة معاكسة تماماً لطريقة إرسال حزمة **Null**، حيث سنقوم هنا بإرسال حزمة فيها جميع المؤشرات. تم تسميتها **Xmas** وذلك إستناداً الى شجرة أعياد الميلاد التي يتم إضائة كل لمبة فيها  وأيضاً الرد عليها يعتمد على نوع النظام الذي تقوم بعملية التحقيق عليه. لنرى الطريقة كيف تتم:

```
# hping2 172.16.0.10 -F -S -R -P -A -U -X -Y -c 1 -p 333
```

من خلال جميع الخطوات التي ذكرتها السابقة نستطيع أن نتحقق هل الهدف موجود أم لا؟ وهل المنفذ مفتوح أم لا؟ وأيضاً ستساعدنا في عملية التحقيق من النظام الموجود على الطرف الآخر والتي تسمى **OS Fingerprinting**. طبعاً جميع الأمور هذه يا شباب تتغيير من نظام الى آخر وأيضاً إن كان المنفذ أو النظام خلف جدار ناري أم لا (يعني مفلتر) … ولهذا في الأجزاء القادمة سنتعلم كيف يمكننا تجاوز الجدار الناري والتحقق هل المنفذ موجود أم لا وكيف يمكننا التعرف على النظام المستهدف وأيضاً كيف نستطيع أن نقوم بإرسال **payload** أو **pre-compiled exploit** من خلال الحزم الى الهدف.

الكلام حول **hping** طوووووووووويل جداً … لا أعلم هل سأستمر بكتابتهم بهذه الطريقة أم أقوم بعملهم على شكل محاظرات مرئية وذلك لضيق الوقت والسرعة … مع عمل محاظرات كامل للـ **nmap** أيضاً … قادم الأيام ستحدد ذلك …

أود أن أشكر صديقي **thehorse13** على مساعدته المستمرة لي في شغلي ورسالتي والتي كانت ذات فائدة كبيرة بالنسبة لي …

Thanks **TH13**, I hope to learn you some Arabic Soon ::18

نراكم قريباً يا شباب … دمتم بود …
